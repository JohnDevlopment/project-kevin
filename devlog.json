{
    "1625617623" : "The dark beast enemy has an idle state and a knockback state. I'm working on the knockback state to improve the way the knockback is handled. As it currently stands, the knockback could use some improvement.\n\nThe thing about it is, when Kevin's hitbox collides with the dark beast's hurtbox, the knockback direction is calculated by getting the direction of the enemy to Kevin and rounding it. So if Kevin is to the left when he swipes at the dark beast, the latter's direction to him is (-1, 0). That direction is then negated to set the dark beast's velocity; thus it goes rightward, away from Kevin.\n\nThe issue here is that Kevin's origin is at the top-left corner of his sprite, so if he attacks the dark beast from the right and is close enough, the dark beast's origin is to the right of Kevin's origin. The result is that the knockback direction is rightward, in Kevin's direction. The issue here is solving that problem.\n\nThe most obvious solution is getting the center point of Kevin and using that for the directional math. And sure enough that could work; however, how will that information make it to the dark beast?\n\nKevin->_on_hit_enemy_hurtbox: Kevin's \"center\" is saved to his stats property as a meta field under the key \"attack_center\". Stats has a method called init_stats() which accepts as parameter the object that owns it, in this case Kevin.\n\n07/08/2021  1:02:44 PM\n\nDark Beast->_on_damaged: get the owner of the stats object through its \"owner\" meta property. If the stats object has an \"attack_center\" meta property use it, otherwise a zero-vector is used instead. This \"center\" offset is added to Kevin's global position in the calculation of the dark beast's direction to him. And so we calculate the enemy's direction to Kevin with this new information.\n\n07/08/2021  1:05:11 PM\n\nI programmed the dark beast to delete itself when it falls off the bottom edge of the level. In this case, the level boundary is at pixel 610, because the default level size at game start is 1020x610.",
    "1625865401" : "The first time Kevin hits the dark beast, it correctly shows its stun frame and gets launched in the opposite direction. But then after the first hit, it doesn't leave its idle animation during its knockback state and its arc is smaller.\n\n------------\nUpdate: 07/09/2021  4:42:07 PM\nThe first time DB is hurt, it goes into the knockback state, during which its horizontal velocity remains constant. But when it touches the ground it goes back into the idle state, where friction gets applied to the velocity. But in the subsequent times it gets hit, DB enters and immediately leaves the knockback state to enter the idle state. This tells me that something changes between the first and second iterations that triggers the exit condition of the knockback state.\n------------\n\nSo let's assign names to two actors: Kevin is the attacker, so he is Kevin, and the dark beast is DB. In this section, DB is the class we're in.\n\n_on_damaged: In variable 'temp' is DB's global position plus the vector (21, 19). In variable 'center_offset' is Kevin's meta property \"attack_center\", or (0, 0) if said property does not exist. The direction vector is the direction from 'temp' to the sum of Kevin's global position and 'center_offset':\n\tdir = direction(temp, Kevin->glob_pos + center_offset);\nIf the health is not zero, that is when DB switches to its knockback state.\n\nIn the idle state, it stops itself by stopping the timer that it uses and stops the current animation that is playing.\n\n07/09/2021  4:54:11 PM\nKnockback state->setup: shift DB's y offset two pixels upward. Get the direction vector and round its x component. Set DB's velocity according to this formula:\n\tV = ( -(dir:x) * speed:x , -speed:y )\nThe X velocity is the x direction negated times the X component of DB's speed cap property. The Y velocity is the Y speed cap negated. Assuming a speed cap of (150, 100) and a direction of -1, the answer to this formula is (150,-100).\n\n07/09/2021  5:11:22 PM\nThe issue was fixed: it appears to be an issue with timing while using is_on_floor(). The flags returned by is_on_floor() and the like are updated while using move_and_slide* functions, so I called move_and_slide() to shift DB's position up slightly in order to update these flags and it not be considered \"on the floor\" when it isn't.",
    "1626048421" : "So far my dark beast has a knockback state and an idle state. Now I want a death state. I chose this rather than the attack state because programming a death animation would be simpler in the short term. That's of course ignoring any external nodes that I would use, like a puff of smoke when an enemy dies. For now, I'mm just make an animation for the enemy landing on its back and deleting itself.",
    "1626203562" : "New function: _on_hit_enemy_hurtbox_adv\nThe function handles the signal for an Area2D. It has four parameters: 1. the instance ID of the area we collided with; 2. the instance of said area; 3. the index of the shape that was collided with; and 4. the index of the shape of our area which collided with number 3.\n\nWhat I want to do is get a point of collision. To do that I need the two collision rectangles for both Kevin and the enemy he strikes. Then I intersect the two rectangles and get the result, and with it I can just get its starting position and use that as a collision point.\n\nThe purpose of all of this is to display a little sprite at the point of collision. That sprite shows an animation of a strike effect.\n\n07/13/2021  3:19:08 PM\nTo accomplish this goal I had to rely on the fact that the enemy uses a hurtbox component, which has a CollisionShape2D as its only child. After getting the enemy's collision rectangle, I offset its position by the global position of the CollisionShape2D. From there all I have to do is intersect the two rectangles, and there you have it--the collision point! Or rather, a rectangle whose position can be used as the collision point."
}
